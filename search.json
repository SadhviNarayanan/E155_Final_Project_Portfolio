[
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "iCE40 UltraPlus Family Data Sheet for FPGA layout especially relating to memory\niCE40 SPRAM Usage Guide to understand how memory is structured and accessed\niCE40 Technology Library for available technologies and IPs on the FPGA - especially for memory layout.\nLattice IPs to understand how to program the PLL.\nLattice ice40 BRAM Usage\nSTM32L432KC Datasheet for MCU programming and configuration\nSTM32L432KC Reference Manual for MCU programming and configuration\nVGA signals for VGA control signals in our VGA controller"
  },
  {
    "objectID": "mcu-design.html",
    "href": "mcu-design.html",
    "title": "MCU Design",
    "section": "",
    "text": "The MCU handles high-level game logic, tracking of asynchronous events, and controlling the FPGA design vis SPI. The program keeps track of how many credits the player has, how much the player is wagering, which sprites are selected when the player spins, and how much the player wins given those sprites. The core game look checks for flags set by interrupt handler functions and sends requests to the FPGA accordingly. When an interrupt is caused by the coin detection circuit, an interrupt handler incrementsthe player’s credit count and sets a flag indicating that an update request is pending to the sent to the FPGA over SPI to update the displayed number of credits on 7-segment displays at the next available time. If instead the spin button causes an interrupt, the interrupt handler sets a flag indicating that a spin request is pending. This flag tells the program to read the GPIO input value at the pins corresponding to the wager selector rotary switch and checks if the player has enough credits to wager that much. If they do, then 3 sprites are selected at random and sent to the the FPGA via a spin request. The program then stalls until the MCU recieves a done signal from the FPGA. At this point, the program calculates how much the player won from their spin, and sends that value to the FPGA in a win request, causing the win value on 7-segment displays to be updated. Finally, the credit count is updated with these winnings, and another update reuest is sent to reflect this on the 7-segment displays.\n\n\n\nCoin Detection (Interrupt-Driven):\n\nExternal interrupt triggered by phototransistor based coin slot.\nIncrements credit count\n\nButton Handling (Interrupt-Driven):\n\nSpin button Interrupt triggers START_SPIN sequence and message to FPGA\nOnly starts game when wager is less that or equal to number of credits\n\nWager/Bet Rotary Switch Control:\n\nDial connected to GPIO pins to control how much the player wants to bet in the current round\n\nGame Logic + SPI:\n\nTracks credits, bets, and winnigs\nGenerates the true random final indices of the displayed icons from within three lists representing the three spinning reels, using these to calculate the player’s winnings and total credits\nSends a 16 bit SPI packet to the FPGA to indicate where the three reels should stop spinning, then another for how many credits the player won, and a final one for how many credits the player has\nWaits for a done signal after the spin sequence\n\n\n\n\n\nFigure 1 demonstrates the process flow for the main program loop\n\n\n\nFigure 1: Main program flow chart\n\n\n\n\n\nWe chose to explore the STM32’s true random number generator perihperal as out new MCU feature for this project. This allows us to produce truly indeterministic sequences of spin results since the RNG is based on an analog noise source as opposed to a seeded deterministic RNG program. To use this peripheral, we created a new library of functions called STM32L432KC_RNG in an analogous form as the GPIO, SPI, and other driver libraries we have used in e155. This library contains setup code to enable the RNG peripheral, as well as a function to get a random number, which contains checks for the RNG being active and truly producing random numbers."
  },
  {
    "objectID": "mcu-design.html#mcu-design",
    "href": "mcu-design.html#mcu-design",
    "title": "MCU Design",
    "section": "",
    "text": "The MCU handles high-level game logic, tracking of asynchronous events, and controlling the FPGA design vis SPI. The program keeps track of how many credits the player has, how much the player is wagering, which sprites are selected when the player spins, and how much the player wins given those sprites. The core game look checks for flags set by interrupt handler functions and sends requests to the FPGA accordingly. When an interrupt is caused by the coin detection circuit, an interrupt handler incrementsthe player’s credit count and sets a flag indicating that an update request is pending to the sent to the FPGA over SPI to update the displayed number of credits on 7-segment displays at the next available time. If instead the spin button causes an interrupt, the interrupt handler sets a flag indicating that a spin request is pending. This flag tells the program to read the GPIO input value at the pins corresponding to the wager selector rotary switch and checks if the player has enough credits to wager that much. If they do, then 3 sprites are selected at random and sent to the the FPGA via a spin request. The program then stalls until the MCU recieves a done signal from the FPGA. At this point, the program calculates how much the player won from their spin, and sends that value to the FPGA in a win request, causing the win value on 7-segment displays to be updated. Finally, the credit count is updated with these winnings, and another update reuest is sent to reflect this on the 7-segment displays.\n\n\n\nCoin Detection (Interrupt-Driven):\n\nExternal interrupt triggered by phototransistor based coin slot.\nIncrements credit count\n\nButton Handling (Interrupt-Driven):\n\nSpin button Interrupt triggers START_SPIN sequence and message to FPGA\nOnly starts game when wager is less that or equal to number of credits\n\nWager/Bet Rotary Switch Control:\n\nDial connected to GPIO pins to control how much the player wants to bet in the current round\n\nGame Logic + SPI:\n\nTracks credits, bets, and winnigs\nGenerates the true random final indices of the displayed icons from within three lists representing the three spinning reels, using these to calculate the player’s winnings and total credits\nSends a 16 bit SPI packet to the FPGA to indicate where the three reels should stop spinning, then another for how many credits the player won, and a final one for how many credits the player has\nWaits for a done signal after the spin sequence\n\n\n\n\n\nFigure 1 demonstrates the process flow for the main program loop\n\n\n\nFigure 1: Main program flow chart\n\n\n\n\n\nWe chose to explore the STM32’s true random number generator perihperal as out new MCU feature for this project. This allows us to produce truly indeterministic sequences of spin results since the RNG is based on an analog noise source as opposed to a seeded deterministic RNG program. To use this peripheral, we created a new library of functions called STM32L432KC_RNG in an analogous form as the GPIO, SPI, and other driver libraries we have used in e155. This library contains setup code to enable the RNG peripheral, as well as a function to get a random number, which contains checks for the RNG being active and truly producing random numbers."
  },
  {
    "objectID": "results.html",
    "href": "results.html",
    "title": "Results",
    "section": "",
    "text": "The final project worked as we had planned out initially, and we were able to meet all our specs. Users can put in coins into the coin detector, which will add to their credit count, and then they can dynamically change the bet/wager amount they want to play under. They can then click on the pushbutton to start a spin, and test their luck to get a winning sequence! Each reel stops at a centered, random sprite each spin, and reel1 stops first, then reel2, and finally reel3. As each reel is about to stop, it also slows down to simulate a real slot machine.\nThe system runs at 25.5 Mhz, with SPI running at around 40Hz. We wanted to have as few clocks as possible to avoid CDC issues. Slthough we did have timing violations in some paths because we had large logic cones and a fast clock, we found ways parallelize the design more, reduce fanout, and pipeline our architecture more to have a stronger positive slack.\nHere is out Slot Machine Project Demo: \nThe project has evolved a lot during the course of our work. The memory controller in particular was quite challening because of how quickly it needs to calcualte the addresses of the sprites on different reels, moving at different speeds, which are being scanned horizontally by the VGA, so this is where a lot of our evolution occured. Below are some of the inital stages of how our VGA looked:\n In Figure 1, we were able to get objects to show up on the VGA in the correct position.\n In Figure 2, were were able to get three reels displaying, with no sprites.\n Figure 3 shows each reel being partitioned into segments which stand for sprites, although all the memory addressing was not working correctly here.\n Figure 4 shows unclear, and distored images because of more memory addressing issues. Additionally, we were limited ot just 3 different sprites, and when we added any more, it would distort all the images.\n Figure 5 shows a stronger effect we experienced in Figure 4, where adding more sprites distorted all the images in unclear ways. This was likely due some EBR optimization happening from the synthesis tool.\n And FINALLY, after a lot of debugging and trial and error, we were able to get all 7 sprites to show up cleanly on the VGA with no distortion!\n Figure 7 shows how our hardware looked before the hardware housing was built.\n\nSimulation Results\nTo ensure proper functionality and to debug subtle timing issues, the team developed unit level testbenches for the VGA controller, SPI rereceiverciever, and memory controller.\n\nVGA controller\nOur testbench for the VGA controller did not have to provide any stimulus aside from clock and reset signals. The testbench let the VGA controller run through several frames, continuously checking the outputs of the desisgn against a set of design properties described with SystemVerilog assertions, which confirm proper timing in acordance to the VGA specification. Figure 8 shows the VGA signal waveforms from this testbench.\n\n\n\nFigure 8: VGA testbench waveforms\n\n\nThese waveforms demonstrate the expected timing of VGA signals, as well as some helper signals for the SystemVerilog assertions.\n\n\nSPI receiver\nOur testbench for the SPI receiver module makes use of a custom SPI send data task which drives the input SPI signals to send 2 bytes of data of SPI to the device under test. This testbench does not self check with assertions, but was used mainly as a tool to investigate timing issues during hardware debugging. As such, this testbench was created to carefully match the clock timing and pulse width of the serial clock signal from the MCU and the internal PLL clock on the MCU. Figure 9 demonstrates the output waveforms from this testbench.\n\n\n\nFigure 9: SPI Receiver waveforms\n\n\nFrom these waves we see a spin request and win request be accepted and properly parsed by the SPI receiver, as demonstrated by the module correctly driving the ending sprite indices and win credits following the two requests.\n\n\nMemory controller\nOur testbench for the memory controller sends a spin request to the memory controller, which produces the RBG pixel values for all pixels on the screen with help from an instance of the VGA controller. In addition to ad-hoc verification by way of investigating waveforms for expected pixel behavior, the design was continuously checked against a set of properties described with SystemVerilog assertions. Figures 10 and 11 demonstrate two of the key behaviors for this module.\n\n\n\nFigure 10: Memory controller waveforms demonstrating proper vsync bahvior\n\n\n\n\n\nFigure 11: Memory controller waveforms demonstrating proper hsync bahvior\n\n\nFrom figure 10, we see that the pixel color is always black surrounding the vsync pulse that ends the frame. Additionally, figure 11 demonstrates that interesting color data is extracted from memory when the hcount value is within one of the spinning reels, otherwise displaying black, as desired.\n\n\n\nQuantitative Analysis\nWe wanted to make our slot machine as accurate as possible to real slot machines. In the gaming insdustry, it is typical to design slots to have around a 85-95% average return for playing a single spin. We wanted to tailor our odds to something close to this. Howver, since our ending sprite selection is true random, the ony way to increase average payout is to make more possible ways to win. To do this, we added a wildcard symbol and made any combination of single and triple bars pay.\nAs part of routine unit testing for the winning calculations, we ran a regression of every possible combination of sprite indices, keeping track of the value won for each combination and taking the average to find the average payout of our slot machine.\n...\nWILD + TPLBAR + TPLBAR       | [WILD, TPL_BAR, TPL_BAR]  | 9        | 9        | PASS \nWILD + TPLBAR + SEVEN        | [WILD, TPL_BAR, SEVEN]    | 0        | 0        | PASS \nWILD + TPLBAR + WILD         | [WILD, TPL_BAR, WILD]     | 9        | 9        | PASS \nWILD + SEVEN + LEMON         | [WILD, SEVEN, LEMON]      | 0        | 0        | PASS \nWILD + SEVEN + CHERRY        | [WILD, SEVEN, CHERRY]     | 0        | 0        | PASS \nWILD + SEVEN + BELL          | [WILD, SEVEN, BELL]       | 0        | 0        | PASS \nWILD + SEVEN + BAR           | [WILD, SEVEN, BAR]        | 0        | 0        | PASS \nWILD + SEVEN + TPLBAR        | [WILD, SEVEN, TPL_BAR]    | 0        | 0        | PASS \nWILD + SEVEN + SEVEN         | [WILD, SEVEN, SEVEN]      | 10       | 10       | PASS \nWILD + SEVEN + WILD          | [WILD, SEVEN, WILD]       | 10       | 10       | PASS \nWILD + WILD + LEMON          | [WILD, WILD, LEMON]       | 2        | 2        | PASS \nWILD + WILD + CHERRY         | [WILD, WILD, CHERRY]      | 3        | 3        | PASS \nWILD + WILD + BELL           | [WILD, WILD, BELL]        | 5        | 5        | PASS \nWILD + WILD + BAR            | [WILD, WILD, BAR]         | 7        | 7        | PASS \nWILD + WILD + TPLBAR         | [WILD, WILD, TPL_BAR]     | 9        | 9        | PASS \nWILD + WILD + SEVEN          | [WILD, WILD, SEVEN]       | 10       | 10       | PASS \nWILD + WILD + WILD           | [WILD, WILD, WILD]        | 10       | 10       | PASS \n---------------------------------------------------------------------------------------------\n\n\nAverage win is 0.962099\nFrom the result of our test program, we see that the average payout is 96.2099%, which is very close to the desired range mentioned above, with odds slightly better for the player."
  },
  {
    "objectID": "team.html",
    "href": "team.html",
    "title": "Team",
    "section": "",
    "text": "Sadhvi is a junior CS major at Harvey Mudd interested in digital and hardware design, processor architecture, hardware-software intersection, and machine learning.\nLinks:\n\nLinkedIn\nGitHub\nPortfolio\n\n\n\n\n\nCorey is a senior engineering major at Harvey Mudd with a background in design verification\nLinks:\n\nLinkedIn\nGitHub\nPortfolio"
  },
  {
    "objectID": "team.html#sadhvi-narayanan",
    "href": "team.html#sadhvi-narayanan",
    "title": "Team",
    "section": "",
    "text": "Sadhvi is a junior CS major at Harvey Mudd interested in digital and hardware design, processor architecture, hardware-software intersection, and machine learning.\nLinks:\n\nLinkedIn\nGitHub\nPortfolio"
  },
  {
    "objectID": "team.html#corey-hickson",
    "href": "team.html#corey-hickson",
    "title": "Team",
    "section": "",
    "text": "Corey is a senior engineering major at Harvey Mudd with a background in design verification\nLinks:\n\nLinkedIn\nGitHub\nPortfolio"
  },
  {
    "objectID": "fpga-design.html",
    "href": "fpga-design.html",
    "title": "FPGA Design",
    "section": "",
    "text": "The FPGA handles all visual output and timing-critical operations for the slot machine. A VGA controller generates sync signals and drives RGB output at 25.5 MHz using the PLL, and a memory controller fetches sprite data from EBR blocks based on the current reel positions and VGA coordinates. The system receives commands from the MCU over SPI—including where each reel should stop and how many credits were won along with the player’s total credit count, in order to create a realistic slot machine animation. We have a couple modules for the seven-segment displays which drive the credit and winnings displays based on values sent from the MCU.\n\n\nThe VGA controller operates at 640×480 resolution, coordinating pixel output through horizontal and vertical timing sequences.\nHorizontal Timing (per scan line)\nEach line spans 800 clock cycles total, broken down as:\n\n640 cycles of active pixel data\n16-cycle front porch\n96-cycle sync pulse\n48-cycle back porch\n\nVertical Timing (per frame)\nEach frame contains 525 lines total:\n\n480 visible lines displaying image content\n10-line front porch\n2-line sync pulse\n\n33-line back porch\n\nThe controller uses counters to track position within these windows. During the 640×480 visible region, it outputs RGB pixel data fetched from memory. Outside this window, RGB outputs go to zero while sync signals coordinate the monitor’s beam positioning for the next frame.\n\n\n\n\nVGA Controller\n\nGenerates horizontal and vertical sync signals (hsync, vsync) which are active-low\nMaintains hcount (0-799) and vcount (0-524) counters that track the current pixel position\nWhen hcount reaches 799, it resets to 0 and increments vcount; when both reach their max, the frame completes and both counters reset\nAsserts active_video signal only during the visible 640×480 display region to gate RGB output\nSync pulses are generated when counters fall within their respective sync timing windows (first 96 horizontal cycles, first 2 vertical lines)\n\nMemory Controller\n\nStores a mapping of unique sprite sequences per reel in lookup tables initialized at synthesis:\n\nReel 1: Sequential (0,1,2,3,4,5,6)\nReel 2: Shuffled (3,0,6,2,4,1,5) to prevent consecutive-value adjacency\nReel 3: Shuffled (2,5,0,3,6,1,4) to prevent consecutive-value adjacency\n\nReceives reel ending symbol indices from SPI module (interfacing with MCU)\nComputes each reel’s pixel offset on frame completion based on the unique sprite pattern for that reel\nTakes in (hcount, vcount) coordinates from VGA controller to:\n\nDetermine which reel the current pixel belongs to (based on horizontal boundaries)\nCalculate vertical position within that reel using (vcount - REEL_START + reel_offset) % TOTAL_HEIGHT\nDerive sprite index by dividing vertical position by scaled sprite height (128 pixels)\nMap sprite index through the reel’s sequence table to get actual sprite number\nCalculate x and y coordinates within the 64×64 sprite, accounting for 2× scaling\n\nImplements a 3-stage pipeline to match ROM latency:\n\nStage 0: Combinational address calculation\nStage 1-2: ROM access with registered control signals\nStage 3: Data alignment and pixel extraction\n\nSequentially stops reels in timed order with realistic deceleration:\n\nDuring START_SPINNING: All reels advance 24 pixels/frame at full speed\nEach reel tracks a spin counter (reel 1 → 3 spins, reel 2 → 2 spins, reel 3 → 2 spins)\nWhen a reel’s counter hits 0, it transitions to its STOP state and slows to 12 pixels/frame\nCalculates target ending offset: (target_sprite_pos × 128 + TOTAL_HEIGHT - centering_offset) % TOTAL_HEIGHT\nSnap-back logic prevents overshooting: if next offset would exceed target, clamp it to exact target value\nThis creates the effect of each reel performing one full rotation before stopping\n\nReels stop at precomputed random positions sent by the MCU via SPI\nHolds final pixel state after all reels stop by maintaining fixed offsets until next spin\nState machine transitions: IDLE → START_SPINNING → REEL1_STOP → REEL2_STOP → REEL3_STOP → IDLE\n\nEach STOP state handles: reel deceleration, snap-back logic, offset preservation for stopped reels, and spin counting for still-moving reels\n\nGenerates yellow border rectangles around the middle row of sprites using precomputed horizontal boundary checks to reduce mux fanout\n\nSymbol ROM Storage\n\nUses 28 of 30 available EBRs on the iCE40 to store 7 sprites, with each sprite spanning 4 EBR blocks\nEBR configuration: 256×16 structure stores 64×64 pixel sprites that get scaled 2× to 128×128 by the memory controller\nData packing: Each 16-bit word holds 4 pixels, with each pixel using 4 bits (3 bits RGB + 1 unused bit for simpler arithmetic since we can use simple bit shifting instead)\nROM wrapper module manages sprite selection:\n\nLower 8 bits of address select word within 256-word EBR\nUpper 2 bits select which of 4 EBRs to access for that sprite\nSprite index (0-6) combined with EBR selector determines which physical ROM to enable\n\nHierarchical muxing reduces fanout: first mux within each sprite’s 4 EBRs, then final mux across all sprites\n2-cycle read latency using registered outputs for better timing closure and signal stability\nROM initialization files loaded at synthesis time from .mem files containing hex pixel data\n\nROM Wrapper\n\nInstantiates 28 individual ROM modules (r1-r28) using both EBR IP blocks and combinational ROMs\nGenerates enable signals based on sprite selection and BRAM selector bits\nImplements 3-stage pipeline to handle ROM latency:\n\nStage 1: Register input address and sprite select\nStage 2: ROM data becomes available\nStage 3: Register ROM outputs and delay control signals to stay synchronized\n\nUses hierarchical multiplexing to reduce critical path:\n\nFirst level: 7 muxes (one per sprite) selecting from 4 EBRs each\nSecond level: Final mux selecting between 7 sprite outputs based on delayed sprite_sel signal\n\nAll outputs registered multiple times to match memory controller pipeline depth\n\nSPI Interface Module\n\nOperates as SPI peripheral with the MCU as controller\nReceives 16-bit commands on COPI line, clocked by sclk from MCU\nFormat: [15:12] = 4-bit request code, [11:0] = 12-bit data payload\nShift register loads data on rising edge of sclk when chip select is low\nAfter 16 bits received, pulses ready signal high for one clock cycle\nThree request types:\n\nREQ_SPIN (0001): Data contains three 4-bit reel indices, asserts start_spin for one cycle\nREQ_WIN (0010): Data contains 12-bit win amount, asserts is_win flag\nREQ_UPDATE (0011): Data contains 12-bit total credits, asserts is_total flag\n\nClock domain crossing: ready signal synchronized from sclk domain to system clk domain\nFlags (start_spin, is_win, is_total) are single-cycle pulses that clear automatically\n\nCredit Controller\n\nManages time-multiplexed seven-segment display output for 5 digits\nReceives credit data: 2 digits for win amount, 3 digits for total credits\nEach digit represented as 4-bit BCD value\nCycles through displays at ~250 Hz using frequency divider (imperceptible to human eye)\nselect_toggle module divides 25.5 MHz clock down to generate 3-bit counter (0-4)\nCounter determines which display is active and which BCD digit gets decoded\nOutput mapping:\n\nenable_sel: 5-bit one-hot signal to NPN transistor bases (active-low)\nseg: 7-bit signal to LED segments (common cathode configuration)\n\nDisplay sequence: win_digit1, win_digit2, credit_digit1, credit_digit2, credit_digit3\n\nPLL Clock Module\n\nInstantiates iCE40 PLL_B primitive to generate 25.5 MHz pixel clock from internal HSOSC\nHSOSC configured to run at 48 MHz using CLKHF_DIV = \"0b00\"\nPLL parameters (strings required by Lattice primitives):\n\nDIVR = \"0\": Reference divider\nDIVF = \"16\": Feedback divider\n\nDIVQ = \"5\": Output divider\nFormula: f_out = (f_ref × (DIVF+1)) / ((DIVR+1) × 2^DIVQ) = (48 MHz × 17) / (1 × 32) = 25.5 MHz\n\nOutputs locked signal indicating PLL has achieved phase lock\nlocked ANDed with external reset_n to generate global reset for rest of design\nRoutes output to both global clock network (OUTGLOBAL) and external pin (OUTCORE) for debug\n\nSelect Toggle Module\n\nDivides system clock to generate display update frequency\nTarget: 250 Hz refresh rate (4 ms per display), requires 102,000 clock cycles at 25.5 MHz\n17-bit counter counts from 0 to 99,999 (close enough to target)\nWhen counter reaches limit, increments 3-bit output counter (0-4) and resets\nOutput counter cycles through 5 displays continuously\n\nSeven Segment Decoder\n\nPure combinational logic converting 4-bit BCD to 7-segment encoding\n\n\n\n\n\n\n\n\nFigure 1: Block Diagram of the project\n\n\n\n\n\nFigure 2: Memory subsystem block diagram\n\n\nThe block diagrams in Figures 1 and 2 demonstrate the overall design and architecture of the design. We can see there are a variety of control modules to handle the VGA display as well as memory accesses (to display the sprites correctly). We also have ROM blocks, and other elements include a SPI module and 7-segment display for other feautures in our design."
  },
  {
    "objectID": "fpga-design.html#fpga-design",
    "href": "fpga-design.html#fpga-design",
    "title": "FPGA Design",
    "section": "",
    "text": "The FPGA handles all visual output and timing-critical operations for the slot machine. A VGA controller generates sync signals and drives RGB output at 25.5 MHz using the PLL, and a memory controller fetches sprite data from EBR blocks based on the current reel positions and VGA coordinates. The system receives commands from the MCU over SPI—including where each reel should stop and how many credits were won along with the player’s total credit count, in order to create a realistic slot machine animation. We have a couple modules for the seven-segment displays which drive the credit and winnings displays based on values sent from the MCU.\n\n\nThe VGA controller operates at 640×480 resolution, coordinating pixel output through horizontal and vertical timing sequences.\nHorizontal Timing (per scan line)\nEach line spans 800 clock cycles total, broken down as:\n\n640 cycles of active pixel data\n16-cycle front porch\n96-cycle sync pulse\n48-cycle back porch\n\nVertical Timing (per frame)\nEach frame contains 525 lines total:\n\n480 visible lines displaying image content\n10-line front porch\n2-line sync pulse\n\n33-line back porch\n\nThe controller uses counters to track position within these windows. During the 640×480 visible region, it outputs RGB pixel data fetched from memory. Outside this window, RGB outputs go to zero while sync signals coordinate the monitor’s beam positioning for the next frame.\n\n\n\n\nVGA Controller\n\nGenerates horizontal and vertical sync signals (hsync, vsync) which are active-low\nMaintains hcount (0-799) and vcount (0-524) counters that track the current pixel position\nWhen hcount reaches 799, it resets to 0 and increments vcount; when both reach their max, the frame completes and both counters reset\nAsserts active_video signal only during the visible 640×480 display region to gate RGB output\nSync pulses are generated when counters fall within their respective sync timing windows (first 96 horizontal cycles, first 2 vertical lines)\n\nMemory Controller\n\nStores a mapping of unique sprite sequences per reel in lookup tables initialized at synthesis:\n\nReel 1: Sequential (0,1,2,3,4,5,6)\nReel 2: Shuffled (3,0,6,2,4,1,5) to prevent consecutive-value adjacency\nReel 3: Shuffled (2,5,0,3,6,1,4) to prevent consecutive-value adjacency\n\nReceives reel ending symbol indices from SPI module (interfacing with MCU)\nComputes each reel’s pixel offset on frame completion based on the unique sprite pattern for that reel\nTakes in (hcount, vcount) coordinates from VGA controller to:\n\nDetermine which reel the current pixel belongs to (based on horizontal boundaries)\nCalculate vertical position within that reel using (vcount - REEL_START + reel_offset) % TOTAL_HEIGHT\nDerive sprite index by dividing vertical position by scaled sprite height (128 pixels)\nMap sprite index through the reel’s sequence table to get actual sprite number\nCalculate x and y coordinates within the 64×64 sprite, accounting for 2× scaling\n\nImplements a 3-stage pipeline to match ROM latency:\n\nStage 0: Combinational address calculation\nStage 1-2: ROM access with registered control signals\nStage 3: Data alignment and pixel extraction\n\nSequentially stops reels in timed order with realistic deceleration:\n\nDuring START_SPINNING: All reels advance 24 pixels/frame at full speed\nEach reel tracks a spin counter (reel 1 → 3 spins, reel 2 → 2 spins, reel 3 → 2 spins)\nWhen a reel’s counter hits 0, it transitions to its STOP state and slows to 12 pixels/frame\nCalculates target ending offset: (target_sprite_pos × 128 + TOTAL_HEIGHT - centering_offset) % TOTAL_HEIGHT\nSnap-back logic prevents overshooting: if next offset would exceed target, clamp it to exact target value\nThis creates the effect of each reel performing one full rotation before stopping\n\nReels stop at precomputed random positions sent by the MCU via SPI\nHolds final pixel state after all reels stop by maintaining fixed offsets until next spin\nState machine transitions: IDLE → START_SPINNING → REEL1_STOP → REEL2_STOP → REEL3_STOP → IDLE\n\nEach STOP state handles: reel deceleration, snap-back logic, offset preservation for stopped reels, and spin counting for still-moving reels\n\nGenerates yellow border rectangles around the middle row of sprites using precomputed horizontal boundary checks to reduce mux fanout\n\nSymbol ROM Storage\n\nUses 28 of 30 available EBRs on the iCE40 to store 7 sprites, with each sprite spanning 4 EBR blocks\nEBR configuration: 256×16 structure stores 64×64 pixel sprites that get scaled 2× to 128×128 by the memory controller\nData packing: Each 16-bit word holds 4 pixels, with each pixel using 4 bits (3 bits RGB + 1 unused bit for simpler arithmetic since we can use simple bit shifting instead)\nROM wrapper module manages sprite selection:\n\nLower 8 bits of address select word within 256-word EBR\nUpper 2 bits select which of 4 EBRs to access for that sprite\nSprite index (0-6) combined with EBR selector determines which physical ROM to enable\n\nHierarchical muxing reduces fanout: first mux within each sprite’s 4 EBRs, then final mux across all sprites\n2-cycle read latency using registered outputs for better timing closure and signal stability\nROM initialization files loaded at synthesis time from .mem files containing hex pixel data\n\nROM Wrapper\n\nInstantiates 28 individual ROM modules (r1-r28) using both EBR IP blocks and combinational ROMs\nGenerates enable signals based on sprite selection and BRAM selector bits\nImplements 3-stage pipeline to handle ROM latency:\n\nStage 1: Register input address and sprite select\nStage 2: ROM data becomes available\nStage 3: Register ROM outputs and delay control signals to stay synchronized\n\nUses hierarchical multiplexing to reduce critical path:\n\nFirst level: 7 muxes (one per sprite) selecting from 4 EBRs each\nSecond level: Final mux selecting between 7 sprite outputs based on delayed sprite_sel signal\n\nAll outputs registered multiple times to match memory controller pipeline depth\n\nSPI Interface Module\n\nOperates as SPI peripheral with the MCU as controller\nReceives 16-bit commands on COPI line, clocked by sclk from MCU\nFormat: [15:12] = 4-bit request code, [11:0] = 12-bit data payload\nShift register loads data on rising edge of sclk when chip select is low\nAfter 16 bits received, pulses ready signal high for one clock cycle\nThree request types:\n\nREQ_SPIN (0001): Data contains three 4-bit reel indices, asserts start_spin for one cycle\nREQ_WIN (0010): Data contains 12-bit win amount, asserts is_win flag\nREQ_UPDATE (0011): Data contains 12-bit total credits, asserts is_total flag\n\nClock domain crossing: ready signal synchronized from sclk domain to system clk domain\nFlags (start_spin, is_win, is_total) are single-cycle pulses that clear automatically\n\nCredit Controller\n\nManages time-multiplexed seven-segment display output for 5 digits\nReceives credit data: 2 digits for win amount, 3 digits for total credits\nEach digit represented as 4-bit BCD value\nCycles through displays at ~250 Hz using frequency divider (imperceptible to human eye)\nselect_toggle module divides 25.5 MHz clock down to generate 3-bit counter (0-4)\nCounter determines which display is active and which BCD digit gets decoded\nOutput mapping:\n\nenable_sel: 5-bit one-hot signal to NPN transistor bases (active-low)\nseg: 7-bit signal to LED segments (common cathode configuration)\n\nDisplay sequence: win_digit1, win_digit2, credit_digit1, credit_digit2, credit_digit3\n\nPLL Clock Module\n\nInstantiates iCE40 PLL_B primitive to generate 25.5 MHz pixel clock from internal HSOSC\nHSOSC configured to run at 48 MHz using CLKHF_DIV = \"0b00\"\nPLL parameters (strings required by Lattice primitives):\n\nDIVR = \"0\": Reference divider\nDIVF = \"16\": Feedback divider\n\nDIVQ = \"5\": Output divider\nFormula: f_out = (f_ref × (DIVF+1)) / ((DIVR+1) × 2^DIVQ) = (48 MHz × 17) / (1 × 32) = 25.5 MHz\n\nOutputs locked signal indicating PLL has achieved phase lock\nlocked ANDed with external reset_n to generate global reset for rest of design\nRoutes output to both global clock network (OUTGLOBAL) and external pin (OUTCORE) for debug\n\nSelect Toggle Module\n\nDivides system clock to generate display update frequency\nTarget: 250 Hz refresh rate (4 ms per display), requires 102,000 clock cycles at 25.5 MHz\n17-bit counter counts from 0 to 99,999 (close enough to target)\nWhen counter reaches limit, increments 3-bit output counter (0-4) and resets\nOutput counter cycles through 5 displays continuously\n\nSeven Segment Decoder\n\nPure combinational logic converting 4-bit BCD to 7-segment encoding\n\n\n\n\n\n\n\n\nFigure 1: Block Diagram of the project\n\n\n\n\n\nFigure 2: Memory subsystem block diagram\n\n\nThe block diagrams in Figures 1 and 2 demonstrate the overall design and architecture of the design. We can see there are a variety of control modules to handle the VGA display as well as memory accesses (to display the sprites correctly). We also have ROM blocks, and other elements include a SPI module and 7-segment display for other feautures in our design."
  },
  {
    "objectID": "acknowledgements.html",
    "href": "acknowledgements.html",
    "title": "Acknowledgements",
    "section": "",
    "text": "Thank you to everyone who helped make this project possible:\n\nProf. Spencer: Thank you so much for such an amazing semester of MicroPs. We learned so much, and were able to apply what we learned to design and build exciting projects we’re proud of. Thank you for creating a really supportive environment for us to learn! This was one of the most memorable classes we’ve taken.\nKavi Dey: Thank you so much for spending so many hours, well beyond what you needed to, answering all our questions so patiently. We really appreciate all your time, effort, and guidance!\nXavier Walters: Thank you so much for all your patience and effort in trying to help us debug any problem that came our way, no matter how big or small. We really appreciate everything you’ve done for us!\nRest of the MicroPs Grutors (Troy, Neil, Vikram): Thank you so much for all your help debugging!\nLynn: Thank you for checking in on us, and buying us snacks to keep us going for our all-nighters!"
  },
  {
    "objectID": "documentation.html",
    "href": "documentation.html",
    "title": "Documentation",
    "section": "",
    "text": "FPGA: Embedded Block RAM (EBR)\n\nThe iCE40 FPGA includes dedicated memory blocks called EBRs, which we used to store all the sprite data for the slot machine symbols. These are separate from the regular LUT logic, so using them frees up LUTs for other parts of the design like our memory controller, VGA controller, SPI transactions etc., especially because we did have a lot of pipelined and combinational logic. Each symbol we used gets stored as a chunk of pixel data in EBR, where we store a 64x64 pixel resolution, and eventually scale it to 128x128 in the VGA. We need 4 ROM blocks per sprite, and on each word we store 4 pixels (each taking up 4 bits, where although we only need 3 using 4 can make logic easier because it allows us to use bit shifting instead of the division operator). The block configuration we used for the EBRs was 256x16. The memory controller reads from these blocks based on the current VGA position and which reel is being displayed. Our EBRs had a two cycle latency because it was using registered outputs as well. Essentially, our symbols are stored sequentially in memory, and the controller calculates the right address offset based on the reel position. When a reel is spinning, the offset keeps changing upon each frame to create the scrolling effect.\n\nMCU: True Random Number Generator (TRNG)\n\nThe STM32L4 has a “true” hardware random number generator that we used to pick where the reels end up. This approach allows us to use analog signals from physical noise in the chip’s circuits to create a true random seed instead of having a software defined pseudo-random number generator. When the player hits the spin button, the MCU gets random values from the TRNG peripheral and uses them to calculate the stopping positions for all three reels. Then the ending sprites for each reel gets sent to the FPGA over SPI, and the visual animation of the spinning reel begins. Using this form of hardware randomness makes the game more fair as you cannot take advantage of a known seed when generating the randomness."
  },
  {
    "objectID": "documentation.html#new-hardware-used-by-our-project",
    "href": "documentation.html#new-hardware-used-by-our-project",
    "title": "Documentation",
    "section": "",
    "text": "FPGA: Embedded Block RAM (EBR)\n\nThe iCE40 FPGA includes dedicated memory blocks called EBRs, which we used to store all the sprite data for the slot machine symbols. These are separate from the regular LUT logic, so using them frees up LUTs for other parts of the design like our memory controller, VGA controller, SPI transactions etc., especially because we did have a lot of pipelined and combinational logic. Each symbol we used gets stored as a chunk of pixel data in EBR, where we store a 64x64 pixel resolution, and eventually scale it to 128x128 in the VGA. We need 4 ROM blocks per sprite, and on each word we store 4 pixels (each taking up 4 bits, where although we only need 3 using 4 can make logic easier because it allows us to use bit shifting instead of the division operator). The block configuration we used for the EBRs was 256x16. The memory controller reads from these blocks based on the current VGA position and which reel is being displayed. Our EBRs had a two cycle latency because it was using registered outputs as well. Essentially, our symbols are stored sequentially in memory, and the controller calculates the right address offset based on the reel position. When a reel is spinning, the offset keeps changing upon each frame to create the scrolling effect.\n\nMCU: True Random Number Generator (TRNG)\n\nThe STM32L4 has a “true” hardware random number generator that we used to pick where the reels end up. This approach allows us to use analog signals from physical noise in the chip’s circuits to create a true random seed instead of having a software defined pseudo-random number generator. When the player hits the spin button, the MCU gets random values from the TRNG peripheral and uses them to calculate the stopping positions for all three reels. Then the ending sprites for each reel gets sent to the FPGA over SPI, and the visual animation of the spinning reel begins. Using this form of hardware randomness makes the game more fair as you cannot take advantage of a known seed when generating the randomness."
  },
  {
    "objectID": "documentation.html#schematic",
    "href": "documentation.html#schematic",
    "title": "Documentation",
    "section": "Schematic",
    "text": "Schematic\n\n\n\nFigure 1: Schematic of the design\n\n\nThe schematic in Figure 1 demonstrates the overall design of how we are connecting the FPGA to the VGA monitor. Because we are only using 3-bit resolution for the pixels, we are scaling the voltage outputs to 0.7 if we want to display a color.\nNOTE: Any pins with a letter following the “P” corresponds to a pin on the MCU (e.g. PA10, PB4), and any pin with just a number following “P” corresponds to a pin on the FPGA (e.g. P21, P47)."
  },
  {
    "objectID": "documentation.html#technical-documentationsource-code",
    "href": "documentation.html#technical-documentationsource-code",
    "title": "Documentation",
    "section": "Technical Documentation/Source Code",
    "text": "Technical Documentation/Source Code\nThe source code for the project can be found in the associated Github repository"
  },
  {
    "objectID": "documentation.html#bill-of-materials",
    "href": "documentation.html#bill-of-materials",
    "title": "Documentation",
    "section": "Bill of Materials",
    "text": "Bill of Materials\n\n\n\nQuantity\nItem\nPrice (incl. Tax & Shipping)\nPurchase Link\n\n\n\n\n1\n7 inch VGA Monitor\n$45.68\nLink to Monitor\n\n\n1\nVGA Cable\nStockroom\nn/a\n\n\n1\nPhototransistor\nStockroom\nn/a\n\n\n1\nLED\nStockroom\nn/a\n\n\n1\nClicky Pushbutton\nStockroom\nn/a\n\n\n1\n4 Way (Rotary) Selector Switch\nStockroom\nn/a\n\n\n5\nSeven Segment Display\nStockroom\nn/a\n\n\n5\nPNP Transistors\nStockroom\nn/a\n\n\n11\n1 kΩ Resistors\nStockroom\nn/a\n\n\n7\n330 Ω Resistors\nStockroom\nn/a\n\n\n5\n10 kΩ Resistors\nStockroom\nn/a\n\n\n1\n10 MΩ Resistor\nStockroom\nn/a\n\n\n1\n47 Ω Resistor\nStockroom\nn/a\n\n\n2\n80 Ω Resistor\nStockroom\nn/a\n\n\n3\n280 Ω Resistor\nStockroom\nn/a\n\n\n1\nMCP6002 Op Amp\nStockroom\nn/a"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Final Project Portfolio Website",
    "section": "",
    "text": "The goal is to create a functional, visually engaging slot machine simulation that:\n\nAccepts a penny slot and “spin” button input.\nDisplays animated reels on a VGA output.\nSequentially stops each reel to show a final symbol combination determined randomly by the MCU.\nCalculates and displays winnings and total credits based on the result.\nUses a coin detector to allow the user to add credits, as well as an adjustable rotary switch to set the wager amounts\n\nThe FPGA will handle the video display including sending information to the VGA and time-sensitive animations, while the MCU will manage the game logic/state, input handling, and random number generation.\nThe system will include: - Three spinning reels rendered on a VGA monitor.\n\nA coin slot, push buttons, and a switch for user interaction:\nSpin Button — initiates reel animation.\nDenomination Switch - indicated how much to bet per spin\nCoin Slot — triggers an interrupt and increments credits using a phototransistor\n5 seven segment displays, 2 for credits won on the previous spin, and 3 for total credits accrued\n\nThe design will interface the MCU and FPGA via SPI communication, allowing the FPGA to render and display the visual state based on the game logic computed by the MCU. Our project meets all the specifications we set."
  },
  {
    "objectID": "index.html#project-abstract",
    "href": "index.html#project-abstract",
    "title": "E155 Final Project Portfolio Website",
    "section": "",
    "text": "The goal is to create a functional, visually engaging slot machine simulation that:\n\nAccepts a penny slot and “spin” button input.\nDisplays animated reels on a VGA output.\nSequentially stops each reel to show a final symbol combination determined randomly by the MCU.\nCalculates and displays winnings and total credits based on the result.\nUses a coin detector to allow the user to add credits, as well as an adjustable rotary switch to set the wager amounts\n\nThe FPGA will handle the video display including sending information to the VGA and time-sensitive animations, while the MCU will manage the game logic/state, input handling, and random number generation.\nThe system will include: - Three spinning reels rendered on a VGA monitor.\n\nA coin slot, push buttons, and a switch for user interaction:\nSpin Button — initiates reel animation.\nDenomination Switch - indicated how much to bet per spin\nCoin Slot — triggers an interrupt and increments credits using a phototransistor\n5 seven segment displays, 2 for credits won on the previous spin, and 3 for total credits accrued\n\nThe design will interface the MCU and FPGA via SPI communication, allowing the FPGA to render and display the visual state based on the game logic computed by the MCU. Our project meets all the specifications we set."
  },
  {
    "objectID": "index.html#project-demo",
    "href": "index.html#project-demo",
    "title": "E155 Final Project Portfolio Website",
    "section": "Project Demo",
    "text": "Project Demo\nSlot Machine Project Demo:"
  },
  {
    "objectID": "index.html#system-block-diagram",
    "href": "index.html#system-block-diagram",
    "title": "E155 Final Project Portfolio Website",
    "section": "System Block Diagram",
    "text": "System Block Diagram\n\n\n\nFigure 1: System level block diagram\n\n\nFigure 1 represents the system level block diagram, highlighting how the MCU, VGA, and our external hardware connect using their respective communication protocols such as SPI and VGA communication."
  }
]