<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>FPGA Design – E155 Final Project: Slot Machine</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-c1fac2584b48ed01fb6e278e36375074.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.scss">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">E155 Final Project: Slot Machine</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./documentation.html"> 
<span class="menu-text">Documentation</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./fpga-design.html" aria-current="page"> 
<span class="menu-text">FPGA Design</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./mcu-design.html"> 
<span class="menu-text">MCU Design</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./results.html"> 
<span class="menu-text">Results</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./team.html"> 
<span class="menu-text">Team</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./references.html"> 
<span class="menu-text">References</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./acknowledgements.html"> 
<span class="menu-text">Acknowledgements</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
    <a href="https://github.com/HMC-E155/final-project-portfolio" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-github"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#fpga-design" id="toc-fpga-design" class="nav-link active" data-scroll-target="#fpga-design">FPGA Design</a>
  <ul class="collapse">
  <li><a href="#vga-timing-protocol" id="toc-vga-timing-protocol" class="nav-link" data-scroll-target="#vga-timing-protocol">VGA Timing Protocol</a></li>
  <li><a href="#core-fpga-modules" id="toc-core-fpga-modules" class="nav-link" data-scroll-target="#core-fpga-modules">Core FPGA Modules</a></li>
  <li><a href="#block-diagram" id="toc-block-diagram" class="nav-link" data-scroll-target="#block-diagram">Block Diagram</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">FPGA Design</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="fpga-design" class="level2">
<h2 class="anchored" data-anchor-id="fpga-design">FPGA Design</h2>
<p>The FPGA handles all visual output and timing-critical operations for the slot machine. A VGA controller generates sync signals and drives RGB output at 25.5 MHz using the PLL, and a memory controller fetches sprite data from EBR blocks based on the current reel positions and VGA coordinates. The system receives commands from the MCU over SPI—including where each reel should stop and how many credits were won along with the player’s total credit count, in order to create a realistic slot machine animation. We have a couple modules for the seven-segment displays which drive the credit and winnings displays based on values sent from the MCU.</p>
<section id="vga-timing-protocol" class="level3">
<h3 class="anchored" data-anchor-id="vga-timing-protocol">VGA Timing Protocol</h3>
<p>The VGA controller operates at 640×480 resolution, coordinating pixel output through horizontal and vertical timing sequences.</p>
<p><strong>Horizontal Timing (per scan line)</strong></p>
<p>Each line spans 800 clock cycles total, broken down as:</p>
<ul>
<li>640 cycles of active pixel data</li>
<li>16-cycle front porch</li>
<li>96-cycle sync pulse</li>
<li>48-cycle back porch</li>
</ul>
<p><strong>Vertical Timing (per frame)</strong></p>
<p>Each frame contains 525 lines total:</p>
<ul>
<li>480 visible lines displaying image content</li>
<li>10-line front porch</li>
<li>2-line sync pulse<br>
</li>
<li>33-line back porch</li>
</ul>
<p>The controller uses counters to track position within these windows. During the 640×480 visible region, it outputs RGB pixel data fetched from memory. Outside this window, RGB outputs go to zero while sync signals coordinate the monitor’s beam positioning for the next frame.</p>
</section>
<section id="core-fpga-modules" class="level3">
<h3 class="anchored" data-anchor-id="core-fpga-modules">Core FPGA Modules</h3>
<ul>
<li><strong>VGA Controller</strong>
<ul>
<li>Generates horizontal and vertical sync signals (<code>hsync</code>, <code>vsync</code>) which are active-low</li>
<li>Maintains <code>hcount</code> (0-799) and <code>vcount</code> (0-524) counters that track the current pixel position</li>
<li>When <code>hcount</code> reaches 799, it resets to 0 and increments <code>vcount</code>; when both reach their max, the frame completes and both counters reset</li>
<li>Asserts <code>active_video</code> signal only during the visible 640×480 display region to gate RGB output</li>
<li>Sync pulses are generated when counters fall within their respective sync timing windows (first 96 horizontal cycles, first 2 vertical lines)</li>
</ul></li>
<li><strong>Memory Controller</strong>
<ul>
<li>Stores a mapping of unique sprite sequences per reel in lookup tables initialized at synthesis:
<ul>
<li>Reel 1: Sequential (0,1,2,3,4,5,6)</li>
<li>Reel 2: Shuffled (3,0,6,2,4,1,5) to prevent consecutive-value adjacency</li>
<li>Reel 3: Shuffled (2,5,0,3,6,1,4) to prevent consecutive-value adjacency</li>
</ul></li>
<li>Receives reel ending symbol indices from SPI module (interfacing with MCU)</li>
<li>Computes each reel’s pixel offset on frame completion based on the unique sprite pattern for that reel</li>
<li>Takes in <code>(hcount, vcount)</code> coordinates from VGA controller to:
<ul>
<li>Determine which reel the current pixel belongs to (based on horizontal boundaries)</li>
<li>Calculate vertical position within that reel using <code>(vcount - REEL_START + reel_offset) % TOTAL_HEIGHT</code></li>
<li>Derive sprite index by dividing vertical position by scaled sprite height (128 pixels)</li>
<li>Map sprite index through the reel’s sequence table to get actual sprite number</li>
<li>Calculate x and y coordinates within the 64×64 sprite, accounting for 2× scaling</li>
</ul></li>
<li>Implements a 3-stage pipeline to match ROM latency:
<ul>
<li>Stage 0: Combinational address calculation</li>
<li>Stage 1-2: ROM access with registered control signals</li>
<li>Stage 3: Data alignment and pixel extraction</li>
</ul></li>
<li>Sequentially stops reels in timed order with realistic deceleration:
<ul>
<li>During <code>START_SPINNING</code>: All reels advance 24 pixels/frame at full speed</li>
<li>Each reel tracks a spin counter (reel 1 → 3 spins, reel 2 → 2 spins, reel 3 → 2 spins)</li>
<li>When a reel’s counter hits 0, it transitions to its STOP state and slows to 12 pixels/frame</li>
<li>Calculates target ending offset: <code>(target_sprite_pos × 128 + TOTAL_HEIGHT - centering_offset) % TOTAL_HEIGHT</code></li>
<li>Snap-back logic prevents overshooting: if next offset would exceed target, clamp it to exact target value</li>
<li>This creates the effect of each reel performing one full rotation before stopping</li>
</ul></li>
<li>Reels stop at precomputed random positions sent by the MCU via SPI</li>
<li>Holds final pixel state after all reels stop by maintaining fixed offsets until next spin</li>
<li>State machine transitions: <code>IDLE → START_SPINNING → REEL1_STOP → REEL2_STOP → REEL3_STOP → IDLE</code>
<ul>
<li>Each STOP state handles: reel deceleration, snap-back logic, offset preservation for stopped reels, and spin counting for still-moving reels</li>
</ul></li>
<li>Generates yellow border rectangles around the middle row of sprites using precomputed horizontal boundary checks to reduce mux fanout</li>
</ul></li>
<li><strong>Symbol ROM Storage</strong>
<ul>
<li>Uses 28 of 30 available EBRs on the iCE40 to store 7 sprites, with each sprite spanning 4 EBR blocks</li>
<li>EBR configuration: 256×16 structure stores 64×64 pixel sprites that get scaled 2× to 128×128 by the memory controller</li>
<li>Data packing: Each 16-bit word holds 4 pixels, with each pixel using 4 bits (3 bits RGB + 1 unused bit for simpler arithmetic since we can use simple bit shifting instead)</li>
<li>ROM wrapper module manages sprite selection:
<ul>
<li>Lower 8 bits of address select word within 256-word EBR</li>
<li>Upper 2 bits select which of 4 EBRs to access for that sprite</li>
<li>Sprite index (0-6) combined with EBR selector determines which physical ROM to enable</li>
</ul></li>
<li>Hierarchical muxing reduces fanout: first mux within each sprite’s 4 EBRs, then final mux across all sprites</li>
<li>2-cycle read latency using registered outputs for better timing closure and signal stability</li>
<li>ROM initialization files loaded at synthesis time from <code>.mem</code> files containing hex pixel data</li>
</ul></li>
<li><strong>ROM Wrapper</strong>
<ul>
<li>Instantiates 28 individual ROM modules (r1-r28) using both EBR IP blocks and combinational ROMs</li>
<li>Generates enable signals based on sprite selection and BRAM selector bits</li>
<li>Implements 3-stage pipeline to handle ROM latency:
<ul>
<li>Stage 1: Register input address and sprite select</li>
<li>Stage 2: ROM data becomes available</li>
<li>Stage 3: Register ROM outputs and delay control signals to stay synchronized</li>
</ul></li>
<li>Uses hierarchical multiplexing to reduce critical path:
<ul>
<li>First level: 7 muxes (one per sprite) selecting from 4 EBRs each</li>
<li>Second level: Final mux selecting between 7 sprite outputs based on delayed sprite_sel signal</li>
</ul></li>
<li>All outputs registered multiple times to match memory controller pipeline depth</li>
</ul></li>
<li><strong>SPI Interface Module</strong>
<ul>
<li>Operates as SPI peripheral with the MCU as controller</li>
<li>Receives 16-bit commands on COPI line, clocked by <code>sclk</code> from MCU</li>
<li>Format: [15:12] = 4-bit request code, [11:0] = 12-bit data payload</li>
<li>Shift register loads data on rising edge of <code>sclk</code> when chip select is low</li>
<li>After 16 bits received, pulses <code>ready</code> signal high for one clock cycle</li>
<li>Three request types:
<ul>
<li><code>REQ_SPIN (0001)</code>: Data contains three 4-bit reel indices, asserts <code>start_spin</code> for one cycle</li>
<li><code>REQ_WIN (0010)</code>: Data contains 12-bit win amount, asserts <code>is_win</code> flag</li>
<li><code>REQ_UPDATE (0011)</code>: Data contains 12-bit total credits, asserts <code>is_total</code> flag</li>
</ul></li>
<li>Clock domain crossing: <code>ready</code> signal synchronized from <code>sclk</code> domain to system <code>clk</code> domain</li>
<li>Flags (<code>start_spin</code>, <code>is_win</code>, <code>is_total</code>) are single-cycle pulses that clear automatically</li>
</ul></li>
<li><strong>Credit Controller</strong>
<ul>
<li>Manages time-multiplexed seven-segment display output for 5 digits</li>
<li>Receives credit data: 2 digits for win amount, 3 digits for total credits</li>
<li>Each digit represented as 4-bit BCD value</li>
<li>Cycles through displays at ~250 Hz using frequency divider (imperceptible to human eye)</li>
<li><code>select_toggle</code> module divides 25.5 MHz clock down to generate 3-bit counter (0-4)</li>
<li>Counter determines which display is active and which BCD digit gets decoded</li>
<li>Output mapping:
<ul>
<li><code>enable_sel</code>: 5-bit one-hot signal to NPN transistor bases (active-low)</li>
<li><code>seg</code>: 7-bit signal to LED segments (common cathode configuration)</li>
</ul></li>
<li>Display sequence: win_digit1, win_digit2, credit_digit1, credit_digit2, credit_digit3</li>
</ul></li>
<li><strong>PLL Clock Module</strong>
<ul>
<li>Instantiates iCE40 PLL_B primitive to generate 25.5 MHz pixel clock from internal HSOSC</li>
<li>HSOSC configured to run at 48 MHz using <code>CLKHF_DIV = "0b00"</code></li>
<li>PLL parameters (strings required by Lattice primitives):
<ul>
<li><code>DIVR = "0"</code>: Reference divider</li>
<li><code>DIVF = "16"</code>: Feedback divider<br>
</li>
<li><code>DIVQ = "5"</code>: Output divider</li>
<li>Formula: f_out = (f_ref × (DIVF+1)) / ((DIVR+1) × 2^DIVQ) = (48 MHz × 17) / (1 × 32) = 25.5 MHz</li>
</ul></li>
<li>Outputs <code>locked</code> signal indicating PLL has achieved phase lock</li>
<li><code>locked</code> ANDed with external <code>reset_n</code> to generate global reset for rest of design</li>
<li>Routes output to both global clock network (<code>OUTGLOBAL</code>) and external pin (<code>OUTCORE</code>) for debug</li>
</ul></li>
<li><strong>Select Toggle Module</strong>
<ul>
<li>Divides system clock to generate display update frequency</li>
<li>Target: 250 Hz refresh rate (4 ms per display), requires 102,000 clock cycles at 25.5 MHz</li>
<li>17-bit counter counts from 0 to 99,999 (close enough to target)</li>
<li>When counter reaches limit, increments 3-bit output counter (0-4) and resets</li>
<li>Output counter cycles through 5 displays continuously</li>
</ul></li>
<li><strong>Seven Segment Decoder</strong>
<ul>
<li>Pure combinational logic converting 4-bit BCD to 7-segment encoding</li>
</ul></li>
</ul>
</section>
<section id="block-diagram" class="level3">
<h3 class="anchored" data-anchor-id="block-diagram">Block Diagram</h3>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/block_diagram.png" class="img-fluid figure-img"></p>
<figcaption>Figure 1: Block Diagram of the project</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/mem_ctrl_block_diagram.png" class="img-fluid figure-img"></p>
<figcaption>Figure 2: Memory subsystem block diagram</figcaption>
</figure>
</div>
<p>The block diagrams in Figures 1 and 2 demonstrate the overall design and architecture of the design. We can see there are a variety of control modules to handle the VGA display as well as memory accesses (to display the sprites correctly). We also have ROM blocks, and other elements include a SPI module and 7-segment display for other feautures in our design.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/SadhviNarayanan\.github\.io\/E155_Final_Project_Portfolio\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>