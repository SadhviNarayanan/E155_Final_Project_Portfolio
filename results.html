<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Results – E155 Final Project: Slot Machine</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-c1fac2584b48ed01fb6e278e36375074.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.scss">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">E155 Final Project: Slot Machine</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./documentation.html"> 
<span class="menu-text">Documentation</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./fpga-design.html"> 
<span class="menu-text">FPGA Design</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./mcu-design.html"> 
<span class="menu-text">MCU Design</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./results.html" aria-current="page"> 
<span class="menu-text">Results</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./team.html"> 
<span class="menu-text">Team</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./references.html"> 
<span class="menu-text">References</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./acknowledgements.html"> 
<span class="menu-text">Acknowledgements</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
    <a href="https://github.com/HMC-E155/final-project-portfolio" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-github"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#simulation-results" id="toc-simulation-results" class="nav-link active" data-scroll-target="#simulation-results">Simulation Results</a></li>
  <li><a href="#quantitative-analysis" id="toc-quantitative-analysis" class="nav-link" data-scroll-target="#quantitative-analysis">Quantitative Analysis</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Results</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>The final project worked as we had planned out initially, and we were able to meet all our specs. Users can put in coins into the coin detector, which will add to their credit count, and then they can dynamically change the bet/wager amount they want to play under. They can then click on the pushbutton to start a spin, and test their luck to get a winning sequence! Each reel stops at a centered, random sprite each spin, and reel1 stops first, then reel2, and finally reel3. As each reel is about to stop, it also slows down to simulate a real slot machine.</p>
<p>The system runs at 25.5 Mhz, with SPI running at around 40Hz. We wanted to have as few clocks as possible to avoid CDC issues. Slthough we did have timing violations in some paths because we had large logic cones and a fast clock, we found ways parallelize the design more, reduce fanout, and pipeline our architecture more to have a stronger positive slack.</p>
<p>Here is out Slot Machine Project Demo: </p><div class="quarto-video ratio ratio-16x9"><iframe data-external="1" src="https://www.youtube.com/embed/zKfxkYHY2ys" title="" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div><p></p>
<p>The project has evolved a lot during the course of our work. The memory controller in particular was quite challening because of how quickly it needs to calcualte the addresses of the sprites on different reels, moving at different speeds, which are being scanned horizontally by the VGA, so this is where a lot of our evolution occured. Below are some of the inital stages of how our VGA looked:</p>
<p><img src="images/IMG_0529.jpg" class="img-fluid" alt="Figure 1: Initial display of shapes"> In Figure 1, we were able to get objects to show up on the VGA in the correct position.</p>
<p><img src="images/IMG_0532.jpg" class="img-fluid" alt="Figure 2: Structure of 3 reels"> In Figure 2, were were able to get three reels displaying, with no sprites.</p>
<p><img src="images/IMG_0541.jpg" class="img-fluid" alt="Figure 3: Paritioned sprites on each reel, but not correct memory extraction"> Figure 3 shows each reel being partitioned into segments which stand for sprites, although all the memory addressing was not working correctly here.</p>
<p><img src="images/IMG_0549.jpg" class="img-fluid" alt="Figure 4: Distored images, limited scope of images"> Figure 4 shows unclear, and distored images because of more memory addressing issues. Additionally, we were limited ot just 3 different sprites, and when we added any more, it would distort all the images.</p>
<p><img src="images/IMG_0574.jpg" class="img-fluid" alt="Figure 5: Memory addressing distoring sprites further"> Figure 5 shows a stronger effect we experienced in Figure 4, where adding more sprites distorted all the images in unclear ways. This was likely due some EBR optimization happening from the synthesis tool.</p>
<p><img src="images/IMG_0647.jpg" class="img-fluid" alt="Figure 6: Perfect 7 sprites"> And FINALLY, after a lot of debugging and trial and error, we were able to get all 7 sprites to show up cleanly on the VGA with no distortion!</p>
<p><img src="images/IMG_0653.jpg" class="img-fluid" alt="Figure 7: Our hardware before we built the hardware housing"> Figure 7 shows how our hardware looked before the hardware housing was built.</p>
<section id="simulation-results" class="level3">
<h3 class="anchored" data-anchor-id="simulation-results">Simulation Results</h3>
<p>To ensure proper functionality and to debug subtle timing issues, the team developed unit level testbenches for the VGA controller, SPI rereceiverciever, and memory controller.</p>
<section id="vga-controller" class="level4">
<h4 class="anchored" data-anchor-id="vga-controller">VGA controller</h4>
<p>Our testbench for the VGA controller did not have to provide any stimulus aside from clock and reset signals. The testbench let the VGA controller run through several frames, continuously checking the outputs of the desisgn against a set of design properties described with SystemVerilog assertions, which confirm proper timing in acordance to the VGA specification. Figure 8 shows the VGA signal waveforms from this testbench.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/vga_ctrl_wave.png" class="img-fluid figure-img"></p>
<figcaption>Figure 8: VGA testbench waveforms</figcaption>
</figure>
</div>
<p>These waveforms demonstrate the expected timing of VGA signals, as well as some helper signals for the SystemVerilog assertions.</p>
</section>
<section id="spi-receiver" class="level4">
<h4 class="anchored" data-anchor-id="spi-receiver">SPI receiver</h4>
<p>Our testbench for the SPI receiver module makes use of a custom SPI send data task which drives the input SPI signals to send 2 bytes of data of SPI to the device under test. This testbench does not self check with assertions, but was used mainly as a tool to investigate timing issues during hardware debugging. As such, this testbench was created to carefully match the clock timing and pulse width of the serial clock signal from the MCU and the internal PLL clock on the MCU. Figure 9 demonstrates the output waveforms from this testbench.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/spi_wave.png" class="img-fluid figure-img"></p>
<figcaption>Figure 9: SPI Receiver waveforms</figcaption>
</figure>
</div>
<p>From these waves we see a spin request and win request be accepted and properly parsed by the SPI receiver, as demonstrated by the module correctly driving the ending sprite indices and win credits following the two requests.</p>
</section>
<section id="memory-controller" class="level4">
<h4 class="anchored" data-anchor-id="memory-controller">Memory controller</h4>
<p>Our testbench for the memory controller sends a spin request to the memory controller, which produces the RBG pixel values for all pixels on the screen with help from an instance of the VGA controller. In addition to ad-hoc verification by way of investigating waveforms for expected pixel behavior, the design was continuously checked against a set of properties described with SystemVerilog assertions. Figures 10 and 11 demonstrate two of the key behaviors for this module.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/mem_ctrl_vsync_wave.png" class="img-fluid figure-img"></p>
<figcaption>Figure 10: Memory controller waveforms demonstrating proper vsync bahvior</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/mem_ctrl_hsync_wave.png" class="img-fluid figure-img"></p>
<figcaption>Figure 11: Memory controller waveforms demonstrating proper hsync bahvior</figcaption>
</figure>
</div>
<p>From figure 10, we see that the pixel color is always black surrounding the vsync pulse that ends the frame. Additionally, figure 11 demonstrates that interesting color data is extracted from memory when the hcount value is within one of the spinning reels, otherwise displaying black, as desired.</p>
</section>
</section>
<section id="quantitative-analysis" class="level3">
<h3 class="anchored" data-anchor-id="quantitative-analysis">Quantitative Analysis</h3>
<p>We wanted to make our slot machine as accurate as possible to real slot machines. In the gaming insdustry, it is typical to design slots to have around a 85-95% average return for playing a single spin. We wanted to tailor our odds to something close to this. Howver, since our ending sprite selection is true random, the ony way to increase average payout is to make more possible ways to win. To do this, we added a wildcard symbol and made any combination of single and triple bars pay.</p>
<p>As part of routine unit testing for the winning calculations, we ran a regression of every possible combination of sprite indices, keeping track of the value won for each combination and taking the average to find the average payout of our slot machine.</p>
<pre><code>...
WILD + TPLBAR + TPLBAR       | [WILD, TPL_BAR, TPL_BAR]  | 9        | 9        | PASS 
WILD + TPLBAR + SEVEN        | [WILD, TPL_BAR, SEVEN]    | 0        | 0        | PASS 
WILD + TPLBAR + WILD         | [WILD, TPL_BAR, WILD]     | 9        | 9        | PASS 
WILD + SEVEN + LEMON         | [WILD, SEVEN, LEMON]      | 0        | 0        | PASS 
WILD + SEVEN + CHERRY        | [WILD, SEVEN, CHERRY]     | 0        | 0        | PASS 
WILD + SEVEN + BELL          | [WILD, SEVEN, BELL]       | 0        | 0        | PASS 
WILD + SEVEN + BAR           | [WILD, SEVEN, BAR]        | 0        | 0        | PASS 
WILD + SEVEN + TPLBAR        | [WILD, SEVEN, TPL_BAR]    | 0        | 0        | PASS 
WILD + SEVEN + SEVEN         | [WILD, SEVEN, SEVEN]      | 10       | 10       | PASS 
WILD + SEVEN + WILD          | [WILD, SEVEN, WILD]       | 10       | 10       | PASS 
WILD + WILD + LEMON          | [WILD, WILD, LEMON]       | 2        | 2        | PASS 
WILD + WILD + CHERRY         | [WILD, WILD, CHERRY]      | 3        | 3        | PASS 
WILD + WILD + BELL           | [WILD, WILD, BELL]        | 5        | 5        | PASS 
WILD + WILD + BAR            | [WILD, WILD, BAR]         | 7        | 7        | PASS 
WILD + WILD + TPLBAR         | [WILD, WILD, TPL_BAR]     | 9        | 9        | PASS 
WILD + WILD + SEVEN          | [WILD, WILD, SEVEN]       | 10       | 10       | PASS 
WILD + WILD + WILD           | [WILD, WILD, WILD]        | 10       | 10       | PASS 
---------------------------------------------------------------------------------------------


Average win is 0.962099</code></pre>
<p>From the result of our test program, we see that the average payout is 96.2099%, which is very close to the desired range mentioned above, with odds slightly better for the player.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/SadhviNarayanan\.github\.io\/E155_Final_Project_Portfolio\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>